\section{Theory}

The method of this study is being made possible from the theory displayed in this section. This section will go through all theory surrounding the building and testing the prototype built in this thesis. These theories are: 
\begin{itemize}
  \item Design
  \item Design software
  \item Web development
  \item Programming languages
  \item Distributing software
  \item Testing methodologies. 
\end{itemize}



% \textit{Don't know were to put this}
% \subsection{Relationship Between Designer and Developer}%
% \label{sub:Relationship Between Designer and Developer}
% To create a great product the collaboration between designers and developers is essential.

% \textit{"Without the proper alignment and synergy of skillsets, the user experience you provide your users will lack efficiency, engagement, and value."} - Khamdamova, \cite{RelationshipDesignersDevelopers} 

\subsection{Design}%
\label{sub:Design}
The design work of a project is primarily held at the start of the project. The project team is in contact with the customer and hash out what functionality and appearance the application will have. With software, it is often hard for customers to know what they want and what is possible to do. Therefore this design segment is often done in iterations.

A fairly common way of making the design of websites is first to create prototypes with little details, called low fidelity prototypes. More details are added to the prototype through iterations until the design could be mistaken for an actual application. This is called a high-fidelity prototype.

The medium with which these prototypes are created varies, but a User Interface (UI) design application is often used to make the final high fidelity prototype. This high-fidelity prototype is visually accurate with the final product meaning that all colors, typographies, and layout are complete. The design prototype then needs to be translated into code by the developer. 

\subsubsection{UI Design Applications}%
\label{ssub:Apps}
User interface (UI) design is often the first step in building an application. By designing the UI first, the designer can collaborate with the customer iteratively until they have a design agreed upon to move forward to development.

Sketch\cite{sketchDigitalDesignToolkit} was released in 2010 and was one of the first UI design applications and lead the market for many years. In later years applications such as Figma\cite{figmaFigmaCollaborativeInterface}  (released 2016) and Adobe XD\cite{adobeAdobeXDFast} (released 2015) have come to overtake Sketch's dominance. 

In this thesis, Figma is the UI design application that is used because Knowit is already using this tool. Figma is also one of few design applications that have an open API which makes this project possible. 

 
% Since the early 10's the UI design applications have been around to make this easier.


% Assesemnt of Figma vs Sketch \cite{SketchVsFigma0200} 




\subsubsection{Figma}%
\label{sub:Figma}
Figma is a UI Design application that is web-based, which means that the whole program is run over a network. 

Figma has an open REST-API (Representational State Transfer) that supplies the information of the Figma document over the Internet\cite{figmaFigma, RepresentationalStateTransfer2021} ( \textit{\todo{Yes men i första hand till en...ja vadå?}} - server?). Figma is also web-based, meaning that Figma itself also runs over a network connection. The API is then constantly updated after each design change, which is great for collaboration and keeping the REST-API updated.

\paragraph{Figma Components}%
\label{ssub:Figma Components}
Figma also allows its users to create components. A component is a set of elements that are combined. Figures \ref{fig:images/cardComp} and \ref{fig:images/cardCompElements} show an example of a card\cite{babichSimpleDesignTips2020} component in Figma. The card component consists of four elements, two text elements, and two frame elements. 

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.48\textwidth}
    \includegraphics[width=\linewidth]{images/cardComp.png}
    \caption{Figma component}
    \label{fig:images/cardComp}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.48\textwidth}
    \includegraphics[width=\linewidth]{images/cardCompElements.png}
    \caption{Elements of a component}
    \label{fig:images/cardCompElements}
  \end{minipage}
\end{figure}


When copying a component, the copied component is \textit{attached} to the original component. When making changes to the original component, all \textit{attached} components will get the updates. The attached components can be changed without affecting the original component. 

\paragraph{Figma Styles}%
\label{ssub:Styles}

Figma has a feature that lets the user store colors, texts, and effects as \textit{styles}. This is a way for the user to store default styles for their design.  For example, if the default color for a design is green, the user can store this green color as a color style. The user can use the color style throughout their user interface (UI). If they later want to change the default color for the UI, they only need to change the color of the color \textit{style}, not all colored elements individually. Effectively the changes between figure \ref{fig:images/layoutBlue} and \ref{fig:images/layoutGreen} are from changing the color style. The same principle extends to typographies and effects such as shadows and blurs. 

\begin{figure}[H]
  \centering
  \begin{minipage}[b]{0.48\textwidth}
    \includegraphics[width=\linewidth]{images/layoutBlue.png}
    \caption{UI with blue color style}
    \label{fig:images/layoutBlue}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.48\textwidth}
    \includegraphics[width=\linewidth]{images/layoutGreen.png}
    \caption{UI with green color style}
    \label{fig:images/layoutGreen}
  \end{minipage}
\end{figure}



% \subsection{Competitors}%
% \label{sub:Competitors}
% The idea of making a design program generate functional code is not new. In this section some of the competitors of this genre of programs will be brought up and compared.

% \subsubsection{Webflow}
% Webflow was founded in 2013 and is a product from the famous program Y Combinator. Webflow allows the user to design, create and publish a website all from their program. Webflow is, as Figma, a network based application that works form a web browser. 



% Webflows website: \cite{ResponsiveWebDesign} 

% \subsubsection{Visly}%
% \label{ssub:Visly}
% Visly website: \cite{vislyVisly} 
% Visly is was founded in 2018 and is very similar to Figma in how the user designs the product. Visly uses the design to create React components \cite{facebookincReactJavaScriptLibrary}. React is a component based JavaScript framework made by Facebook. Visly essentially makes it possible to create these components visually.

% \subsubsection{Bravo}%
% \label{ssub:Bravo}

% Build Native IOS och Android apps with Figma. Think this can be the closest to the what I'm trying to do. 

% \subsubsection{Comparison}%
% \label{ssub:Comparison}



% \subsubsection{Components}%
% \label{sub:Components}

\subsection{Develop}%
\label{sub:Develop}

Developing something from a design is essential to make the design functional with code. A design is often more like an image rather than an application. A website is usually built using the three main languages of the web: \acrfull{html}, CSS, and JavaScript. HTML is a \textit{''tagging''} language meaning all code is written with tags. All information is written between or in opening and closing tags. An opening tag signifies a tag with  <\textit{nameOfTag}> and a closing tag </\textit{nameOfTag}>. Within the opening tag, attributes can be assigned, such as a class or an id. 
HTML is often referred to as the body of a website. This is where the majority of the information on the web pages is stored. CSS is the clothes to the body. CSS is what defines the style for the website, such as sizes, paddings, and colors.\\
\textit{"CSS describes how HTML elements are to be displayed on screen, paper, or in other media"}\cite{CSSIntroduction}.\\
JavaScript is a scripting language that enables us to create complex features on web pages. JavaScript enables us to update the content of the website dynamically. 

In modern web design, many different frameworks and languages make it easier for developers to create products.  All these tools have one thing in common. They all convert to the three browser languages mentioned above. 

One of the thesis objectives is to create a tool that could be used in as many projects as possible. Knowit is, as explained in the intro, a large company that has many different projects using lots of different frameworks. 


\subsubsection{REST API}%
\label{sub:REST API}
REST stands for \textbf{Re}presentational \textbf{S}tate \textbf{T}ransfer and is anarchitectural style of distributed hypermedia systems. Roy Fielding created this in 2000 with the release of his dissertation [12]. For an API to be called RESTful, it needs to fill the following six requirements [13]. 

\begin{enumerate}
  \item Client-server - the UI and data storage are separated:w. 
  \item Stateless - The server does not store any information about the client. The client must provide all information for every request. 
  \item Cacheable - A response can be explicitly or implicitly labeled as cacheable or non-cacheable. If the response is cacheable, the client has the right to store and reuse the response data for later. 
  \item Uniform interface - Simplifies and decouples the architecture between clients and servers, which enables each part to evolve independently. Four principles guide this: Resource-Based, Manipulation of Resources Through Representation, Self-descriptive Messages, Hypermedia as the Engine of Application State [14]. 
  \item Layered system - This architecture consists of hierarchical layers that constrain what each component can do, such as; a component can only interact with the layer it is on. 
  \item Code on demand (optional) - This allows the client to download and execute applets or scripts and therefore extending client functionality 
\end{enumerate}

These requirements make it lightweight and easy to understand and thereby introduce fewer problems into the system. 


\subsubsection{JavaScript and TypeScript}%
\label{ssub:JavaScript and TypeScript}

JavaScript is a programming language that reports its error much later than many other languages. Variables can take any shape in JavaScript. That is, for instance, a number or a string. This can at first seem as good that the language is highly dynamic and flexible. This flexibility is also very error-prone, where most of the errors are discovered after the code is run. This results in being obliged to test running the code after every change\cite{taivalsaari2008web}. TypeScript was created to fix the error-prone nature of JavaScript. TypeScript is an open-source programming language that is built upon JavaScript. TypeScript allows for the creation of types for variables, functions, etc., and thereby helps to find more errors before runtime. TypeScript then complies back to JavaScript before it is run and can thereby run everywhere JavaScript run.  


% \textit{Incremental testing is required. Due to its highly permissive, error-tolerant nature, JavaScript programming requires an incremental, evolutionary approach to testing as well. Since errors are reported much later than usual, by the time an error is reported it is often surprisingly difficult to pinpoint the original location of the error. Error detection is made harder by the dynamic nature of JavaScript, for instance, by the option to change some of the system features on the fly. Furthermore, in the absence of strong, static typing, it is possible to execute a program and only at runtime realize that some parts of the program are missing. For all these reasons, the best way to write JavaScript programs is to proceed step by step, by writing (and immediately testing) each new piece of code. If such an incremental, evolutionary approach is not used, debugging and testing can become quite tedious even for relatively small JavaScript applications.} 



\subsubsection{Node.js}%
\label{ssub:Node}
Node.js is an open-source project that lets its users run code on the server asynchronously. This allows for a more efficient way of running JavaScript code without a browser. Node.js is designed to handle HTTP effectively. Streaming and low latency have therefore been a high priority. 


\subsubsection{Syntactically Awesome Style Sheets (SASS)}%
\label{sub:sass}
SASS is an extension language to CSS that adds more functionality to regular CSS. With SASS, it is possible to have a stylesheet split up into multiple files, create functions, etc. SASS is then compiled to regular CSS so the browser can understand it. SASS is also called a preprocessor for CSS because of this. SASS has two different syntaxes; the indented syntax, commonly referred to as SASS, and Sassy CSS, referred to as SCSS. The indented syntax was the original syntax for SASS and is only dependent on indentation. SCSS syntax is very similar to regular CSS but with the qualities of SASS. Because of the resembles of standard CSS, SCSS is the easiest to learn and most famous of the two syntaxes. For this project, SCSS will be used because it resembles CSS. 

\paragraph{Variables}
Variables in a stylesheet are helpful, especially when dealing with colors. Often websites have color schemes from their design. By assigning each color to a variable, only one row of code needs to be changed if the color scheme is updated. Regular CSS does support variables, but they can be cumbersome to use, especially if the variables will be used globally in the stylesheet.

To style an element in CSS, we must first target the element with a CSS selector. A selector could be an HTML element such as a div or a heading. CSS also has additional selectors called pseudo-elements. Pseudo-elements are defined by a colon before their name, such as :after, :before, and :root. These elements do not add additional data to the website but help the developer to style it. 

A variable in CSS is defined by adding two dashed before the variable name.  The variable must also be defined within a selector and thereby only operate within that selector. The :root pseudo-element can be used to define variables globally within the stylesheet. When using the variables, they must be put inside the var()-function to work.
Below an example of defining and using a variable can be seen. 

\begin{lstlisting}[style=htmlcssjs]

:root{
  --myColorVariable: #ff9a67; 
}

div{
  background-color: var(--myColorVariable);
}
\end{lstlisting}


SCSS variables are not required to be defined within a selector, making them globally reachable within the stylesheet by default. The dollar-sign (''\$'') is used to define an SCSS variable. We can use an SCSS variable by simply adding the variable where we want to use it. The example below is achieving the same result as the previous example.


\begin{lstlisting}[style=htmlcssjs]
\$myColorVariable: #ff9a67; 

div{
  background-color: \$myColorVariable;
}
\end{lstlisting}


\paragraph{Mixin and Include}
CSS is notoriously known for having many code duplications. These duplications occur when the same styling for different elements is needed. SCSS has a solution to this called mixins. A mixin is a sort of function that stores multiple CSS rules defined with @mixin before the function name and used with @include. Below is an example of centering all children in an element with a mixin. 

\begin{lstlisting}[style=htmlcssjs]
@mixin centered {
  display: grid;
  place-items: center;
}; 

div{
  @include centered; 
}
\end{lstlisting}

% \subsubsection{CSS Methodologies}%
% \label{ssub:methodologies}

% Explanation for BEM\cite{contributorsBEMBlockElement} 

% \subsubsection{SCSS}%
% \label{ssub:SCSS}
% \cite{SassSyntacticallyAwesome} 

% \subsubsection{Webpack}%
% \label{sub:Webpack}




\subsubsection{Web Components}%
\label{sub:Web Components}
Web Components are a set of different JavaScript APIs and HTML features that make it possible to create reusable custom elements\cite{WebComponentsMDN}. These elements are encapsulated away from the rest of the code. All major browsers support these web components. Because web components are run natively on HTML, CSS, and JavaScript, they are compatible with all JavaScript frameworks, such as React, Vue, and Angular. Web components are built with three technologies: Custom elements, shadow DOM, and HTML Templates. 

\paragraph{Custom Elements}
With the help of a set of JavaScript APIs, we can define custom elements and their behavior. By creating custom elements, we can encapsulate HTML functionality outside of the main page itself. By doing this, the HTML code becomes much more readable. 

\paragraph{Shadow DOM}%
\label{ssub:Shadow DOM}
When the browser reads in an HTML page, a document object model tree (DOM tree) is created.  In figure \ref{fig:shadow}, we can see this tree. Shadow DOM is a set of JavaScript APIs that lets us attach an encapsulated ''shadow'' DOM tree to an existing node in the DOM tree. This ''shadow'' DOM extends the main document DOM like a branch. The difference from a regular branch is that the main DOM is not aware of the ''shadow'' DOMs data or functionality and vice versa. The ''shadow'' DOM is then essentially its own tree with its own stylesheet that cannot be modified or overwritten from the main DOM.\\
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/shadow.png}
  \caption{Depiction of a shadow DOM attached to the main DOM}%
  \label{fig:shadow}
\end{figure}

\todo{Lägga till bättre bild}



\paragraph{HTML Templates}%
\label{ssub:HMTL Templates}
The HTML \textit{template}-tag and \textit{slot}-tag enable you to write markup templates that are not displayed on the rendered HTML page. Which then can be reused throughout the HTML page. HTML templates enable web components to be reused multiple times, with different instances, in the DOM tree.

\subsubsection{LitElement}%
\label{ssub:LitElement}
Web components can be manually built using custom elements, shadow DOM, and HTML templates mentioned above. A group of engineers from the Google Chrome team in the Polymer Project \cite{polymerPolymerProject} have built a lightweight class called LitElement. LitElement combines functionality from the web components technologies to a class that makes it easy to create web components with concise and malleable code.


% \subsubsection{Recursive functions}%
% \label{ssub:Recursive functions}
% A small but very powerful caviat of programming is recursive fucntions. This is when a funcions calls itself inside said function.






\subsection{Distribute}%
\label{sub:Distribute}
After a \gls{component} has been designed and developed, the components can now be used in a project. Often the created component is used by more than one part, and therefore it should be distributed seamlessly. There are many ways to distribute a component, but the most widely used way is to use a package manager.


% To be able to use the components created from the designer the developers need to be able to get a hold of them. A lot of reusable code that is crated for the web can be accessed from the internet with the help of package managers.
\subsubsection{Package Manager}%
\label{sub:Package Manager}
% \cite{PackageManager2020} 

The most traditional way of installing and updating software is to download an installer. This installer will then install the software to the system, which can then be used. If an update is needed, the software can notify the user to update or update itself in the background.

A package manager is a way to install and update software with ease compared to a more traditional installer. A package manager bundles up the source code into a package. This package can then be distributed over the Internet and installed and updated without an internal installer. 

The package manager that this project will use is Node Package Manager (NPM), which is the world's largest software registry\cite{NpmNpmDocs}.
NPM has a straightforward interface, whereas if something needs to be installed, the following can be typed: 


\begin{lstlisting}[style=htmlcssjs]
\$npm install PACKAGE-NAME
\end{lstlisting}

\subsubsection{Open Source}%
\label{ssub:Open Source}

\textit{The term open source refers to something people can modify and share because its design is publicly accessible.} - Opensource.com 

Open source originated from developers creating software that was designed to be open and modified by anyone. In an open-source project, the source code for the software must be available for others to use. To signify that the project is open-source, an open-source license is added to the source code. These licenses affect how the user can use, study, distribute, and modify the software's source code. The most used licenses state that the user can do anything they wish with the software. Some licenses state that if alterations are done on the software, the altered version must also be open-source. 

% \subsection{Semi-Structured Interviews}%
% \label{sub:inteviews}
% This tool is involved with people in many different areas of expertise, form designers to front-end developers to back-end developers. To get a clear view of of how these people work to create the best tool for them the semi-structured interview was used. 

% For collecting data from the employees of Knowit semi-structured interviews were used \cite{galletta2013mastering}. 





\subsection{Testing}%
\label{sub:Testing}
When a product has been created, tests can be run on the product. The test's main objective is to find contingent bugs in the software and flaws with the UI. Further, the testing is done to ensure that assumptions taken when creating the product are verified.

\subsubsection{Usability testing}%
\label{ssub:User testing}
Usability testing or "user research" is a broad term. As Lewis\cite{lewis2006usability} described it: "Usability testing, in general, involves representative users attempting representative tasks in representative environments, on early prototypes or working versions of computer interfaces." 

Usability testing is essentially performed to find flaws in an interface by putting the user in the environment of using the interface. Usability testing is done in all stages of development, from paper prototypes to high-fidelity screen mock-ups. 

Lazar et al.\cite[Chapter~10]{lazar2017research}  consider usability testing a cousin to traditional research methods, where traditional research refers to methods such as experimental design\cite[Chapter~3]{lazar2017research}  and ethnography\cite[Chapter~9]{lazar2017research}.
Similarities can be found in experimental design with measurement of task performance and time performance, surveys, and observation techniques from ethnography. The participants in usability testing, as in traditional research, must remain anonymous, be informed of their rights, and can leave the research at any time. What separates usability testing from traditional research is often the end goals. For usability testing, the end goals are to create the best product possible, with the time and resources at hand, while the traditional research methods want to find answers to questions that are universal for the field researched. 
	
Wixson proclaims in his study that usability testing is closer to engineering than traditional research \cite{wixon2003evaluating}. Usability testing, as engineering, is focused on creating a successful product with limited time and resources. Tests are done in iterations where the prototype will be changed between each test to fix the flaws found during the test. The next iteration of tests will then be used to verify the fixed flaws simultaneously as it searches for other flaws. This is, in most if not all traditional research, considered unacceptable. 

To get more credible data out of a test and not just for improving the product, the test environment should be kept as similar as possible for each user. By doing this, the data can be statistically analyzed, making it easier to make more accurate decisions of what to do next.

Usability testing can collect quantitative data such as time- and task performance. However, the majority of data that is collected is qualitative. As mentioned before, the most significant end goal for a usability test is to uncover flaws in the user interface, which is often subjective for the user. 

\textit{"Often in industry, schedule and resource issues, rather than theoretical discussions of methodology, drive the development process \cite{wixon2003evaluating}."}

\paragraph{Sufficient Amount of Test Users}
\label{ssub:Sufficient Amount of Test Users}

In usability testing, it has become widely accepted that five users are the most efficient number of participants for usability testing.  Nielsen and Landauer suggest the number five out of a cost ratio to numbers of tests\cite{nielsen1993mathematical}. Nielsen started the \textit{''discount usability movement''} in 1989 with his presentation of the paper: "Usability Engineering at a Discount"\cite{experienceDiscountUsability20}. This \textit{movement} tries to find cost-effective methods for usability testing. 
From Nielsen and Landauer's study, they found that the number of usability problems found in a usability test with n users is:
\[ N (1-(1- L ) n ) \]

Where \textit{N} is the total number of usability problems and  \textit{L} is the proportion of problems found by one test user. With this, they determined that when using five users, 80\% of usability problems are found.

Lazar, et al. explains that many researchers disagree with the assertion of five test users for successful usability testing because of Nielsen and Landauer approximation of the total number of usability problems\cite[Chapter~10.5.3]{lazar2017research}. This number \textit{N} is probably unknown, and therefore the number of test users \textit{n} cannot be found.

The topic of what number of test users are sufficient for usability testing has been discussed for over 30 years. What is important to point out is that performing usability testing is valuable to do than not to do. 


\textit{
So instead of saying, “how many users must you have?,” maybe the correct question is “how many users can we afford?,” “how many users can we get?” or “how many users do we have time for?”
} \cite{lazar2017research} 



% \cite{nielsen1994estimating} 

% \cite{nielsen1994heuristic} 




\subsubsection{A/B Testing}%
\label{sub:A/B Testing}
A/B testing, or bucket testing, is a user experience (UX) research method where two variants of a program/interface are tested. These two variants are referred to as A and B, hence the name A/B testing. The A and the B variant are tested on the user and then their responses are compared and evaluated. Often just a small change is made in a UI and evaluated on a lot of people 
 
A/B testing is verified using two-sample hypothesis testing from the field of statistics. This means that decisions be made completely based on data. Then there is no guessing on where to go next.




\subsubsection{Statistical Analysis}%
\label{sub:Statistical analysis}
When data has been collected a statistical analysis needs to be done to be able to make any ''hard'' conclusions. A lot of decisions need to be made when analyzing the collected data. What statistical method to be used, the confidence threshold, and how the interpretation and significance of the test results should be. If the wrong method is used or if the interpretation of the results is inappropriate the conclusions drawn from the study can be erroneous \cite{lazar2017research}. 


\textbf{Preparing Data:} before we can do anything with the data often the data must be cleaned and organized.\\
\textbf{Descriptive statistic:} when the data has been cleaned and organized it can be a good idea to run some tests to understand the nature of the data. This can unfold what patterns or tendencies lays in the data. This makes it easier to choose the correct statistical method for the collected data at hand.\\
% Skillnad mellan analys och resultat: Analys = laga mat, Resultat = servera mat.
\textbf{Analyze:} when we understand the nature of the data we can analyze the data with the help of a statistical analysis method. This method could be a T- or F-tests, chi-squared test, etc. depending on the data collected.\\ 
\textbf{Results:} when the analysis is done the results must be interpreted according to the methods used.\\


% \paragraph{Preparing Data}%
% \label{ssub:Preparing Data}
% \textbf{Cleaning data}
% \textbf{Organizing}

% \paragraph{What does the data look like?}%
% \label{ssub:data look like}
% \textbf{Tendency's}
% \textbf{Patterns}
% \textbf{What statistical method should be used?}

% \paragraph{Analyze and compare}%
% \label{ssub:Analyze and compare}

% \paragraph{Summary and results}%
% \label{ssub:Summary and results}

% \begin{itemize}
%   \item Preparing data
%     \begin{itemize}
%       \item Cleaning data
%       \item Organizing 
%     \end{itemize}
%   \item What does the data look like?
%     \begin{itemize}
%       \item Tendency's
%       \item Patterns
%       \item What methods should be used?
%     \end{itemize}
%   \item Analyze and compare
%   \item Summary and results
% \end{itemize}

