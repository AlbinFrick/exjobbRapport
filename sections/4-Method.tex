\section{Method}
% \textit{
% This system was thought of as a tool to be used in many different projects. Because of this the mark on accessibility was big. The developer should not be constrained on what framework or lack there of he or she is using. This should work on all platforms.
% }

In this section the methods used to fulfill the research questions (see section \ref{sub:Objective}) will be presented. In the start of the project a literature study was performed to get an overview of what similar work had been done in the field and see what could be used as inspiration and what not do to. A tool was built to fill the need of the company connected to the study, Knowit. Throughout this process Knowit was involved with semi-weekly checkups to hold the project on the right course. Semi-Structured interviews where done on the employees of Knowit to steer the development of the tool to fit them. When a prototype was somewhat complete iterations of usability testing were done on the employees on Knowit and on students in University of Umeå where perform. This do insure that the tool were usable for more people then the developer himself. Lastly to investigate what impacted the tool created could have a A/B test where scheduled to be preformed.

\subsection{Initial Research}%
\label{sub:Initial Research}

In the start of the project a meeting was held with a team at Knowit on what their needs where and what requirements they had on the project. After some discussion there was an interest in creating an automated generating of code from their UI design program, Figma. With this in mind research began on what competitors there was in the field of code generation for web applications, here two competitors where most interesting, Webflow and Visly,(see section \ref{sub:Competitors}). Some interesting small projects where also found that were saved and used as inspiration for creating the tool. One project especially of creating color variables form Figma made by Karl Rombauts was used \cite{rombautsKarlRombautsFigmaSCSSGenerator2021}. How to encapsulate the Figma design elements into code where one the biggest problems. Many different technologies were researched to find the fit for Knowits requirements.


% \begin{itemize}
%   \item Möte med knowit om behov och krav.
%   \item vad fanns för konkurrenter.
%   \item vilka liknande projekt fanns?
%   \item Vilka verktyg passade in knowits behov.

% \end{itemize}


\subsection{Creating the tool}%
\label{sub:}
% After the interviews and research phase a clear understanding of the tools that would be used was had. (<--haha what) For creating the tool it self TypeScript was used to be able to use types to find problems before they crashed the code. LitElement was then used to 


Meetings with Knowit and where discussions of what could be possible to do under the 20 weeks of work that should be carried out. As seen from the literature study the big problem was how to condense the elements in from the code to easly be used. 

Identifying the tools that should be used.
\begin{itemize}
  \item TypeScript - for building the tool.
  \item Exploring Figmas API.
  \item LitElement - For building the components. 
  \item Building the html elements and styling with recursive functions
\end{itemize}

To build the tool an experimental approach with \textbf{TypeScript} was used. This means that code where tested and possibilities where explored during the building of the program. Why \textbf{TypeScript}? because of the unknown possibilities at the start of the development there where some thoughts on making the generator part of the component itself. Thereby the browser had to be able to run the code which made JavaScript a good match. Because of the error prone nature of JavaScript (discussed in section \ref{ssub:JavaScript and TypeScript}) TypeScript, the supercharged version of JavaScript, was chosen. TypeScript need to be compiled to JavaScript before it can be run in a browser but that hassle is worth the benefits of getting error warnings before runtime.

To understand what could be done with Figmas API it first had to be examined. Figmas website for developers\cite{figmaFigma} was read through and also some initial HTTP-requests where sent to the API, using platform Postman \cite{PostmanCollaborationPlatform}. The initial response from the API where quite large. This meant that setting the TypeScript types correct for all values in the response would take alot of time. To mitigate this the Visual Studio Code \cite{VisualStudioCode} extension quicktype\cite{ConvertJSONSwift} was used to generate types from the JSON response. 

From the response we could see that most, or at least enough, of the data were the same as styling in CSS. This meant that styling elements with CSS was possible from the API. To create a website we need some markup, HTML, to attach the styling to. HTML was created in 1993, back then modularity and component compatibility where not important. The first suggestion to solve this issue was to build a separate HTML-file and then use that as a sub-file to the main HTML-file. This could've worked for a static page with some browsers. But the requirements for the project are that the components can be used for all frameworks too. To solve this the tool LitElement was used. LitElement (\ref{ssub:LitElement}) is a class that builds web-components (\ref{ssub:Custom Elements}), HTML templates (\ref{ssub:HMTL Templates}) and shadow-DOM (\ref{ssub:Shadow DOM}). Which combined makes for a really good way of building components. LitElement is a class in TypeScript and JavaScript where we choose to use the TypeScript version to keep the program code consistent. 

The information from Figmas API is stored as classes of colors, typographies, and components. Where the components class can contain the other two.  The strategy was to generate a string that contained the LitElement. Essentaially the program generated code as a string. This string is later written into a new file.

\subsubsection{Building the skeleton of the component}%
\label{ssub:building the skeleton of the component}
To build the HTML inside the LitElement the data-object from Figmas API where run through a recursive function that is run on the component and all it's children (elements).

\subsubsection{Styling the Component}%
\label{ssub:Styling the component}
For the first ''attempt'' styling where done in a similar way but because of the nature of the shadow-DOM every CSS-attribute where assigns a property which was reachable from outside the component. This was later redesigned because of the fact that the user could not add a new CSS-attribute to the component if they wished to. To fix this the CSS-attributes where stored in maps \cite{ArrayPrototypeMap} and then pushed in to a style element. Instead of creating a property for each style attribute, only one property for each element is created. If the user wishes to add and/or change the styling of an component they target the element as an attribute to the component and inputs regular CSS. The component then creates a duplicate of the styling map for the targeted element and inserts the new styling attributes to the component.


\subsubsection{Variables}%
\label{ssub:Variables}
Figma has a feature called styles. This a way for the user too store and reuse, colors, texts and effects. This is somehting that is also very normal to do in a developer environment. Therefore a decision was made to create a SCSS \textit{variable} file where these would be stored. Because of the time constraint of the project only colors and texts where implmented. This was done similar to the components where the ''code'' for the SCSS variables where written to a string that later were written into a SCSS file. 

\subsubsection{Open Source}%
\label{ssub:Open Source}
One of Knowits initial requirements where that the software produced should be open source (see section \ref{ssub:Open Source}). The project was handed access to Knowit experience norrlands github page. The software was uploaded publicly to this github repository. The MIT\cite{MITLicenseOpen} open source license where then attached to the repository stating that the software is free to use but has not liability or warranty.
 
\subsubsection{Userguide}%
\label{ssub:Userguide}
The program built does not have a graphical user inteface, again because of the time constraint. The user is instead using a command-line interface (CLI). This makes it a bit harder to learn because there are no visual queues of what to input to the program. To solve this a user guide was created in the form of a README on GitHub\cite{BuildSoftwareBetter}. Alon side the prototype itself this user guide was altered after the usability tests.

% knowit uses a supercharged version of css called scss in most of their projects (section \ref{sub:sass}). scss handles variables in a more intuitive way than regular  css which made it the clear choice for storing styling variables moving forward.







\subsection{Semi-Structured Interviews}%
\label{sub:inteviews}
This tool is involved with people in many different areas of expertise, form designers to front-end developers to back-end developers. To get a better view of how these people work and create the best tool for them a semi-structured interview model was used \cite{galletta2013mastering}. The semi-structure interview is done with a script of questions that are asked to every interviewee. Unlike the structure interview the semi-structured interview allows for further explanation and follow up questions from the interviewer. These interviews where done on seven employees of Knowit Experience Umeå and Sundsvall. 

Because of the broad nature of the tool created it was important to get participants that worked with all effected areas of expertise. The interviews were done digitally over Microsoft Teams. The script used for these interviews can be found in the appendix (The script is only in Swedish). (\todo{lägg till appendix}).


% \subsection{interviews from knowit}%
% \label{sub:}
% to get an understanding of what the tool should be able to do and how it should operate. semi-structured interviews were held with (??seven??) employees of knowit.




\subsection{Usability Testing}%
\label{sub:usertesting}
To make great product it must have great functionality but also great usability. These test where done to make sure that the prototype was usable for somebody else than the author. Furthermore to set up the prototype for further testing regarding the effectiveness of the prototype.

Two iterations of usability testing was carried out on nine participants, four the first iteration and five the second. The participants had to have a background in web development, NPM, and Figma.  Therefore the participants chosen for the tests where employees of Knowit and students from the interaction and design program in University of Umeå. The test were laid out as a scenario with four different tasks. The participant first got a link to the GitHub repository where the tool and the user guide were situated. The tasks were to create a viable Figma component that could be converted to a web component using the created tool. There after the participant should install the tool on their computer. Use the tool to convert the Figma component and then insert the component, using NPM locally, in a test project supplied by the test administrator.

This was a way to test the whole chain from design to component usage for the tool and to determine what was working and not in the user guide. After the tasks where done the questions about the experience where asked. Finally the test administrator opened up for suggestions regarding improvements of the tool or the user guide. 

The test script was altered after the first iteration to target more features of the prototype. These features where the use of color and text styles. The questions from the first iteration where still asked. This to confirm that the changes made between iteration one and two were effective. 


\subsection{ A/B Testing }%
\label{sub:ab-testing}

To have a metric that can be measured, discussed, and statistically verifiable whether or not the prototype is effective in real world use, A/B tests will be performed. A number tests will be done with two participants in each test. The two participants is complied by one designer and one developer that work together to get the tasks done. The test participants will get a design of a web page written out on a document. The participants task is then together design and code the website. Once with the tool created in this project and once without it. If they create the page without the tool first or second will be randomized for each test to try to dampened the learning effect. When the test have been performed a statistical analysis, section \ref{sub:Statistical analysis}, will be performed to see what the data can say about the tool.


