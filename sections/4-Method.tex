\section{Method}
% \textit{
% This system was thought of as a tool to be used in many different projects. Because of this the mark on accessibility was big. The developer should not be constrained on what framework or lack there of he or she is using. This should work on all platforms.
% }

In this section, the methods used to answer the research questions (see section \ref{sub:Objective}) will be presented. At the beginning of the project, a literature study was performed. This to get an overview of what similar work existed in the field. Knowit, the company connected to the study, wanted an easier way to create components for web development projects. A tool was built to fulfill this want. 

Throughout this process, Knowit was involved with semi-weekly checkups for support. Semi-Structured interviews were carried out on the employees of Knowit to steer the development of the tool to fit their needs. 

When a prototype was somewhat complete, iterations of usability testing were performed. This was done to ensure that the tool was usable for more people than just the author. Lastly, to investigate what impacted the created tool could have, an A/B test was scheduled to be performed.

\subsection{Initial Research}%
\label{sub:Initial Research}

At the start of the project, a meeting was held with a team at Knowit on what their needs were and what requirements they had on the project. After some discussion, there was an interest in creating an automated generating of code from their UI design program, Figma. With this in mind, research began on what competitors there were in the field of code generation for web applications, here two competitors were most interesting, Webflow and Visly,(see section \ref{sub:Competitors}). Some interesting small projects were also found that were saved and used as inspiration for creating the tool. One project especially of creating color variables from Figma made by Karl Rombauts was used \cite{rombautsKarlRombautsFigmaSCSSGenerator2021}. How to encapsulate the Figma design elements into code was one of the biggest problems. Many different technologies were researched to find the fit for Knowit's requirements.


% \begin{itemize}
%   \item Möte med knowit om behov och krav.
%   \item vad fanns för konkurrenter.
%   \item vilka liknande projekt fanns?
%   \item Vilka verktyg passade in knowits behov.

% \end{itemize}


\subsection{Creating the tool}%
\label{sub:}
% After the interviews and research phase a clear understanding of the tools that would be used was had. (<--haha what) For creating the tool it self TypeScript was used to be able to use types to find problems before they crashed the code. LitElement was then used to 


Meetings with Knowit and where discussions of what could be possible to do under the 20 weeks of work that should be carried out. As seen from the literature study the big problem was how to condense the elements from the code to easily be used. 

Identifying the tools that should be used.
\begin{itemize}
  \item TypeScript - for building the tool.
  \item Exploring Figmas API.
  \item LitElement - For building the components. 
  \item Building the HTML elements and styling with recursive functions
\end{itemize}

To build the tool an experimental approach with \textbf{TypeScript} was used. This means that code where tested and possibilities where explored during the building of the program. Why \textbf{TypeScript}? because of the unknown possibilities at the start of the development, there were some thoughts on making the generator part of the component itself. Thereby the browser had to be able to run the code which made JavaScript a good match. Because of the error-prone nature of JavaScript (discussed in section \ref{ssub:JavaScript and TypeScript}) TypeScript, the supercharged version of JavaScript was chosen. TypeScript needs to be compiled to JavaScript before it can be run in a browser but that hassle is worth the benefits of getting error warnings before runtime.

To understand what could be done with Figmas API it first had to be examined. Figmas website for developers\cite{figmaFigma} was read through and also some initial HTTP-requests were sent to the API, using platform Postman \cite{PostmanCollaborationPlatform}. The initial response from the API was quite large. This meant that setting the TypeScript types correct for all values in the response would take a lot of time. To mitigate this the Visual Studio Code \cite{VisualStudioCode} extension quicktype\cite{ConvertJSONSwift} was used to generate types from the JSON response. 

From the response, we could see that most, or at least enough, of the data were the same as styling in CSS. This meant that styling elements with CSS were possible from the API. To create a website we need some markup, HTML, to attach the styling too. HTML was created in 1993, back then modularity and component compatibility was not important. The first suggestion to solve this issue was to build a separate HTML file and then use that as a sub-file to the main HTML file. This could've worked for a static page with some browsers. But the requirements for the project are that the components can be used for all frameworks too. To solve this the tool LitElement was used. LitElement (\ref{ssub:LitElement}) is a class that builds web-components (\ref{ssub:Custom Elements}), HTML templates (\ref{ssub:HMTL Templates}) and shadow-DOM (\ref{ssub:Shadow DOM}). Which combined makes for a really good way of building components. LitElement is a class in TypeScript and JavaScript where we choose to use the TypeScript version to keep the program code consistent. 

The information from Figmas API is stored as classes of colors, typographies, and components. Where the component's class can contain the other two.  The strategy was to generate a string that contained the LitElement. Essentially the program generated code as a string. This string is later written into a new file.

\subsubsection{Building the skeleton of the component}%
\label{ssub:building the skeleton of the component}
To build the HTML inside the LitElement the data object from Figmas API was run through a recursive function that is run on the component and all its children (elements).

\subsubsection{Styling the Component}%
\label{ssub:Styling the component}
For the first ''attempt'' styling was similarly but because of the nature of the shadow-DOM, every CSS-attribute where assigns a property that was reachable from outside the component. This was later redesigned because of the fact that the user could not add a new CSS attribute to the component if they wished to. To fix this the CSS attributes were stored in maps \cite{ArrayPrototypeMap} and then pushed into a style element. Instead of creating a property for each style attribute, only one property for each element is created. If the user wishes to add and/or change the styling of a component they target the Figma element as an attribute to the component and inserts regular CSS. The component then creates a duplicate of the styling map for the targeted element and inserts the new styling attributes into the component.


\subsubsection{Variables}%
\label{ssub:Variables}
Figma has a feature called styles. This is a way for the user to store and reuse, colors, texts, and effects. This is something that is also very normal to do in a developer environment. Therefore a decision was made to create an SCSS \textit{variable} file where these would be stored. Because of the time constraint of the project only colors and texts were implemented. This was done similar to the components where the ''code'' for the SCSS variables was written to a string that later was written into an SCSS file. 

\subsubsection{Open Source}%
\label{ssub:Open Source}
One of Knowit's initial requirements where that the software produced should be open source (see section \ref{ssub:Open Source}). The project was handed access to Knowit Experience Norrlands GitHub page. The software was uploaded publicly to this GitHub repository. The MIT\cite{MITLicenseOpen} open source license where then attached to the repository stating that the software is free to use but has no liability or warranty.
 
\subsubsection{Userguide}%
\label{ssub:Userguide}
The program built does not have a graphical user interface, again because of the time constraint. The user is instead using a command-line interface (CLI). This makes it a bit harder to learn because there are no visual queues of what to input into the program. To solve this a user guide was created in the form of a README on GitHub\cite{BuildSoftwareBetter}. Alon side the prototype itself this user guide was altered after the usability tests.

% knowit uses a supercharged version of css called scss in most of their projects (section \ref{sub:sass}). scss handles variables in a more intuitive way than regular  css which made it the clear choice for storing styling variables moving forward.







\subsection{Semi-Structured Interviews}%
\label{sub:inteviews}
This tool is involved with people in many different areas of expertise, from designers to front-end developers to back-end developers. To get a better view of how these people work and create the best tool for them a semi-structured interview model was used \cite{galletta2013mastering}. The semi-structured interview is done with a script of questions that are asked to every interviewee. Unlike the structured interview, the semi-structured interview allows for further explanation and follow-up questions from the interviewer. These interviews were done on seven employees of Knowit Experience Umeå and Sundsvall. 

Because of the broad nature of the tool created it was important to get participants that worked with all affected areas of expertise. The interviews were done digitally over Microsoft Teams. The script used for these interviews can be found in the appendix (The script is only in Swedish). (\todo{lägg till appendix}).


% \subsection{interviews from knowit}%
% \label{sub:}
% to get an understanding of what the tool should be able to do and how it should operate. semi-structured interviews were held with (??seven??) employees of knowit.




\subsection{Usability Testing}%
\label{sub:usertesting}
To make a great product it must have great functionality but also great usability. These tests were done to make sure that the prototype was usable for somebody else than the author. Furthermore to set up the prototype for further testing regarding the effectiveness of the prototype.

Two iterations of usability testing were carried out on nine participants, four the first iteration and five the second. The participants had to have a background in web development, NPM, and Figma. Therefore the participants that were chosen for the tests were employees of Knowit and students from the interaction and design program at the University of Umeå. The test was laid out as a scenario with four different tasks. The participant first got a link to the GitHub repository where the tool and the user guide were situated. The tasks were to create a viable Figma component that could be converted to a web component using the created tool. Thereafter the participant should install the tool on their computer. Use the tool to convert the Figma component and then insert the component, using NPM locally, in a test project supplied by the test administrator.

This was a way to test the whole chain from design to component usage for the tool and to determine what was working and not in the user guide. After the tasks were done the questions about the experience were asked. Finally, the test administrator opened up for suggestions regarding improvements to the tool or the user guide. 

The test script was altered after the first iteration to target more features of the prototype. These features where the use of color and text styles. The questions from the first iteration were still asked. This to confirm that the changes made between iteration one and two were effective. 



\subsection{ A/B Testing }%
\label{sub:ab-testing}

To have a metric that can be measured, discussed, and statistically verifiable whether or not the prototype is effective in real-world use, A/B tests will be performed. Several tests will be done with two participants in each test. The two participants are complied by one designer and one developer that work together to get the tasks done. The test participants will get a design of a web page written out on a document. The participants' task is then together design and develop the website. Once with the tool created in this project and once without it. If they create the page without the tool first or second will be randomized for each test to try to dampen the learning effect. When the test has been performed a statistical analysis, section \ref{sub:Statistical analysis}, will be performed to see what the data can say about the tool.


