\section{Method}

\textit{
This system was thought of as a tool to be used in many different projects. Because of this the mark on accessibility was big. The developer should not be constrained on what framework or lack there of he or she is using. This should work on all platforms.
}


\subsection{Workflow and Actions taken}%
\label{sub:workflow}

\begin{enumerate}
  \item Literature study / External analysis
    \begin{itemize}
      \item Research which tools to use
    \end{itemize}
  \item Preform interviews/collect data for the workflow that is used today in the company.
  \item Create a tool that uses Figmas API to create components (testing accessibility/"code quality" trough out)
  \item Preform user testing to ensure usability. 
  \item Finalize tool with certain demarcations.
  \item Preform AB testing to study efficiency with and without the new tool for starting up a project.
\end{enumerate}

\subsection{Literature study}%
\label{sub:Literature study}
How to communicate? 
How to build relationship? 
How to easier build products?

The subject at hand was thoroughly 


\subsection{Creating the tool}%
\label{sub:}
% After the interviews and research phase a clear understanding of the tools that would be used was had. (<--haha what) For creating the tool it self TypeScript was used to be able to use types to find problems before they crashed the code. LitElement was then used to 


Meetings with Knowit and where discussions of what could be possible to do under the 20 weeks of work that should be carried out. As seen from the literature study the big problem was how to condense the elements in from the code to easly be used. 

Identifying the tools that should be used.
\begin{itemize}
  \item TypeScript - for building the tool.
  \item Exploring Figmas API.
  \item LitElement - For building the components. 
  \item Building the html elements and styling with recursive functions
\end{itemize}

To build the tool an experimental approach with \textbf{TypeScript} was used. This means that code where tested and possibilities where explored during the building of the program. Why \textbf{TypeScript}? because of the unknown possibilities at the start of the development there where some thoughts on making the generator part of the component itself. Thereby the browser had to be able to run the code which made JavaScript a good match. Because of the error prone nature of JavaScript (discussed in section \ref{ssub:JavaScript and TypeScript}) TypeScript, the supercharged version of JavaScript, was chosen. TypeScript need to be compiled to JavaScript before it can be run in a browser but that hassle is worth the benefits of getting error warnings before runtime.

To understand what could be done with Figmas API it first had to be examined. The website \url{https://www.figma.com/developers/api} was read through and also some initial HTTP-requests where sent to the API, using platform Postman \cite{PostmanCollaborationPlatform}. The initial response from the API where quite large. This meant that setting the TypeScript types correct for all values in the response would take alot of time. To mitigate this the Visual Studio Code \cite{VisualStudioCode} extension quicktype\cite{ConvertJSONSwift} was used to generate types from the JSON response. 

From the response we could see that most, or at least enough, of the data were the same as styling in CSS. This meant that styling elements with CSS was possible from the API. Styling is one thing but how do we build the skeleton of the page? the HTML. HTML was born 28 years ago. Back then modularity and component compatibility where not important. The first suggestion to solve this issue was to build a separate HTML-file and then use that as a sub-file to the main HTML-file. This could've worked for a static page with some browsers. But the requirements for the project are that the components can be used for all frameworks too. To solve this the tool LitElement was used. LitElement (\ref{ssub:LitElement}) is a class that builds web-components (\ref{ssub:Custom Elements}), HTML templates (\ref{ssub:HMTL Templates}) and shadow-DOM (\ref{ssub:Shadow DOM}). Which combined makes for a really good way of building components. LitElement is a class in TypeScript and JavaScript where we choose to use the TypeScript version to keep the program code consistent. 

\textit{Should mention that the coding method used is object-oriented, but don't know where}

The information from Figmas API is stored as classes of colors, typographies, and components. Where the components class can contain the other two.  The strategy was to generate a string that contained the LitElement. Essentaially the program generated code as a string. This string is later written into a new file.

\subsubsection{Building the skeleton of the component}%
\label{ssub:building the skeleton of the component}
To build the HTML inside the LitElement the data-object from Figmas API where run through a recursive function that is run on the component and all it's children (elements).

\subsubsection{Styling the Component}%
\label{ssub:Styling the component}
For the first ''attempt'' styling where done in a similar way but because of the nature of the shadow-DOM every CSS-attribute where assigns a property which was reachable from outside the component. This was later redesigned because of the fact that the user could not add a new CSS-attribute to the component if they wished to. To fix this the CSS-attributes where stored in maps \cite{ArrayPrototypeMap} and then pushed in to a style element. Instead of creating a property for each style attribute, only one property for each element is created. If the user wishes to add and/or change the styling of an component they target the element as an attribute to the component and inputs regular CSS. The component then creates a duplicate of the styling map for the targeted element and inserts the new styling attributes to the component.


\subsubsection{Variables}%
\label{ssub:Variables}
Figma has a feature called styles. This a way for the user too store and reuse, colors, texts and effects. This is somehting that is also very normal to do in a developer environment. Therefore a decision was made to create a SCSS \textit{variable} file where these would be stored. Because of the time constraint of the project only colors and texts where implmented. This was done similar to the components where the ''code'' for the SCSS variables where written to a string that later were written into a SCSS file. 


\subsubsection{Userguide}%
\label{ssub:Userguide}
The program built does not have a graphical user inteface, again because of the time constraint. The user is instead using a command-line interface (CLI) instead. This makes it a bit harder to learn because there are no visual queues of what to input to the program. To solve this a userguide was created in the form of a README on GitHub. This userguide was written as the program were developed. When the program was functional usertesting where preformed to test the validity of the userguide and if there were any prototype breaking bugs. \textit{ \textbf{there was and they were fixed... atleast soon.} }

% knowit uses a supercharged version of css called scss in most of their projects (section \ref{sub:sass}). scss handles variables in a more intuitive way than regular  css which made it the clear choice for storing styling variables moving forward.






\subsection{semi-structured interviews}%
\label{sub:inteviews}
This tool is involved with people in many different areas of expertise, form designers to front-end developers to back-end developers. To get a clear view of of how these people work to create the best tool for them a semi-structured interview model was used \cite{galletta2013mastering}(see section \ref{sub:Interviews}). These interviews where done on seven employees on 


% \subsection{interviews from knowit}%
% \label{sub:}
% to get an understanding of what the tool should be able to do and how it should operate. semi-structured interviews were held with (??seven??) employees of knowit.



\subsection{Usability Testing}%
\label{sub:usertesting}
The user testing where carried out 


\subsection{ finalized prototype }%
\label{sub:finalizingprototype}


\subsection{ ab testing }%
\label{sub:mabtesting}

